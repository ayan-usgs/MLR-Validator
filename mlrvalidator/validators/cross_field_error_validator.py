
from .base_cross_field_validator import BaseCrossFieldValidator

class Cross_Field_Error_Validator(BaseCrossFieldValidator):

    def __init__(self):
        '''

        :param object site_type_reference: should be a references.SiteTypesCrossField instance
        '''
        super().__init__()

    def _validate_location(self):
        keys = [
            'latitude',
            'longitude',
            'coordinateAccuracyCode',
            'coordinateDatumCode',
            'coordinateMethodCode'
        ]
        if self._any_fields_in_document(keys):
            self._validate_reciprocal_dependency(keys, 'location')

    def _validate_altitude(self):
        keys = [
            'altitude',
            'altitudeDatumCode',
            'altitudeMethodCode',
            'altitudeAccuracyValue'
            ]
        if self._any_fields_in_document(keys):
            self._validate_reciprocal_dependency(keys, 'altitude')

    def _validate_use_code(self, use_key_ending):
        keys = ['primary{0}'.format(use_key_ending), 'secondary{0}'.format(use_key_ending), 'tertiary{0}'.format(use_key_ending)]
        if self._any_fields_in_document(keys):
            primary, secondary, tertiary = [self.merged_document.get(key, '').strip() for key in keys]

            if tertiary and (not primary or not secondary):
                self._errors.append({use_key_ending: 'Primary and secondary must be non null if tertiary is non null'})
            elif secondary and not primary:
                self._errors.append({use_key_ending: 'Primary must be non null if secondary is non null'})
            elif (primary and secondary and tertiary) and ((primary == secondary) or (primary == tertiary) or (secondary == tertiary)):
                self._errors.append({use_key_ending: 'Primary, secondary, and tertiary fields must be unique'})
            elif (primary and secondary and not tertiary) and (primary == secondary):
                self._errors.append({use_key_ending: 'Primary and secondary must be unique'})

    def _validate_site_dates(self):
        keys = ['firstConstructionDate', 'siteEstablishmentDate']
        if self._any_fields_in_document(keys):
            construction_date, inventory_date = [self.merged_document.get(key, '').strip() for key in keys]
            if (construction_date and inventory_date) and (construction_date > inventory_date):
                self._errors.append({'site_dates': "firstConstructionDate cannot be more recent than siteEstablishmentDate"})

    def _validate_depths(self):
        keys = ['holeDepth', 'wellDepth']
        if self._any_fields_in_document(keys):
            try:
                hole_depth, well_depth = [float(self.merged_document.get(key, '').strip()) for key in keys]
            except ValueError:
                pass
            else:
                if (hole_depth and well_depth) and (well_depth > hole_depth):
                    self._errors.append({'depths': "wellDepth cannot be greater than holeDepth"})



    def validate(self, document, existing_document):
        '''
        After validate is called the error property will reflect the errors generated by the last call to validate
        :param dict document:
        :param dict existing_document:
        :return: boolean
        '''

        super().validate(document, existing_document)
        self._validate_location()
        self._validate_altitude()
        self._validate_use_code('UseOfSite')
        self._validate_use_code('UseOfWaterCode')
        self._validate_site_dates()
        self._validate_depths()


        return self._errors == []

    @property
    def errors(self):
        return self._errors
